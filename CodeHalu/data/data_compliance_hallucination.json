[
    {
        "id": 325,
        "task_id": 1697,
        "test_case_id": 1,
        "question": "Fox Ciel is playing a mobile puzzle game called \"Two Dots\". The basic levels are played on a board of size n \u00d7 m cells, like this:\n\n[Image]\n\nEach cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.\n\nThe key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d_1, d_2, ..., d_{k} a cycle if and only if it meets the following condition:\n\n  These k dots are different: if i \u2260 j then d_{i} is different from d_{j}.  k is at least 4.  All dots belong to the same color.  For all 1 \u2264 i \u2264 k - 1: d_{i} and d_{i} + 1 are adjacent. Also, d_{k} and d_1 should also be adjacent. Cells x and y are called adjacent if they share an edge. \n\nDetermine if there exists a cycle on the field.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (2 \u2264 n, m \u2264 50): the number of rows and columns of the board.\n\nThen n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.\n\n\n-----Output-----\n\nOutput \"Yes\" if there exists a cycle, and \"No\" otherwise.\n\n\n-----Examples-----\nInput\n3 4\nAAAA\nABCA\nAAAA\n\nOutput\nYes\n\nInput\n3 4\nAAAA\nABCA\nAADA\n\nOutput\nNo\n\nInput\n4 4\nYYYR\nBYBY\nBBBY\nBBBY\n\nOutput\nYes\n\nInput\n7 6\nAAAAAB\nABBBAB\nABAAAB\nABABBB\nABAAAB\nABBBAB\nAAAAAB\n\nOutput\nYes\n\nInput\n2 13\nABCDEFGHIJKLM\nNOPQRSTUVWXYZ\n\nOutput\nNo\n\n\n\n-----Note-----\n\nIn first sample test all 'A' form a cycle.\n\nIn second sample there is no such cycle.\n\nThe third sample is displayed on the picture above ('Y' = Yellow, 'B' = Blue, 'R' = Red).",
        "solutions": "[\"#!/usr/bin/env python\\n\\nimport sys\\n\\nsys.setrecursionlimit(10000)\\n\\nn, m = list(map(int, input().split(' ')))\\n\\ndef neighbors(i, j):\\n    return [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\\n\\ndef valid(i, j):\\n    nonlocal n, m\\n    if i < 0 or i >= n or j < 0 or j >= m:\\n        return False\\n    return True\\n\\ndef dfs(f, i, j):\\n    color = f[i][j]\\n    f[i][j] = color.lower()\\n    c = 0\\n    for n, m in neighbors(i, j):\\n        if valid(n, m):\\n            if f[n][m] == color:\\n                cycle_found = dfs(f, n, m)\\n                if cycle_found:\\n                    return True\\n            elif f[n][m] == color.lower():\\n                c += 1\\n    if c > 1:\\n        return True\\n\\n    f[i][j] = None\\n\\n    return False\\n\\nf = []\\nfor i in range(n):\\n    f.append(list(input().strip()))\\n\\nfor i in range(n):\\n    for j in range(m):\\n        if f[i][j]:\\n            cycle_found = dfs(f, i, j)\\n            if cycle_found:\\n                print(\\\"Yes\\\")\\n                return\\n\\nprint(\\\"No\\\")\\n\", \"import sys\\nsys.setrecursionlimit(10000)\\n\\nn, m = map(int, input().split())\\nA = []\\n\\nfor i in range(n):\\n    A.append(input() + '1')\\n\\nA.append('1' * (m + 1))\\nans = 0\\nused = [[False] * m for i in range(n)]\\nB = ''.join(A)\\nB = list(set(B))\\ndef dfs(i, j, b, c):\\n    nonlocal ans\\n    used[i][j] = True\\n    \\n    if A[i - 1][j] == b and c != 3:\\n        if used[i - 1][j]:\\n            ans = 1\\n        else:\\n            dfs(i - 1, j, b, 1)\\n\\n    if A[i][j + 1] == b and c != 4:\\n        if used[i][j + 1]:\\n            ans = 1\\n        else:\\n            dfs(i, j + 1, b, 2)\\n\\n    if A[i + 1][j] == b and c != 1:\\n        if used[i + 1][j]:\\n            ans = 1\\n        else:\\n            dfs(i + 1, j, b, 3)\\n\\n    if A[i][j - 1] == b and c != 2:\\n        if used[i][j - 1]:\\n            ans = 1\\n        else:\\n            dfs(i, j - 1, b, 4)\\n\\nfor i in range(len(B)):\\n    used = [[False] * m for i in range(n)]\\n    if B[i] != '1':\\n        b = B[i]\\n        for x in range(n):\\n            for y in range(m):\\n                if A[x][y] == b and not used[x][y]:\\n                    dfs(x, y, b, -1)\\n\\nif ans == 0:\\n    print('No')\\nelse:\\n    print('Yes')\", \"import math\\nln, cl = (int(x) for x in input().split())\\n\\nin_dt = []\\n\\nfor i in range(ln):\\n    in_dt.append(input())\\n\\ndef is_adj(x_1, y_1, x_2, y_2):\\n    if math.abs(x_2 - x_1) == 1 and y_2 - y_1 == 0:\\n        return True\\n    elif math.abs(y_2 - y_1) == 1 and x_2 - x_1 == 0:\\n        return True\\n    return False\\n\\nch_dt = [[0 for x in range(55)] for y in range(55)]\\n\\ndef neighb(x, y, ln, cl, lst):\\n    res = []\\n    if x - 1 >= 0 and lst[x][y] == lst[x - 1][y]:\\n        res.append((x - 1, y))\\n    if y - 1 >= 0 and lst[x][y] == lst[x][y - 1]:\\n        res.append((x, y - 1))\\n    if x + 1 < ln and lst[x][y] == lst[x + 1][y]:\\n        res.append((x + 1, y))\\n    if y + 1 < cl and lst[x][y] == lst[x][y + 1]:\\n        res.append((x, y + 1))\\n    return res\\n\\npath = []\\n\\ndef go_path(lst, path):\\n    nonlocal ln\\n    nonlocal cl\\n    while True:\\n        if len(path) == 0:\\n            break\\n        cur_x = path[-1][0]\\n        cur_y = path[-1][1]\\n        del path[-1]\\n        #print (cur_x, cur_y)\\n        #print (path)\\n        neighbours = neighb(cur_x, cur_y, ln, cl, lst)\\n        #print(neighbours)\\n        if len(neighbours) != 0:\\n            for neighbour in neighbours:\\n                if neighbour in path:\\n                    return True\\n                # print (\\\"_______\\\")\\n                #print (ch_dt)\\n                #print (neighbour)\\n                #print (\\\"+++++++\\\")\\n                if ch_dt[neighbour[0]][neighbour[1]] == 0: \\n                    path.append(neighbour)\\n                    ch_dt[neighbour[0]][neighbour[1]] = 1\\n        #print(path)\\n    #print (False)\\n    return False\\nfor i in range(ln):\\n    for j in range(cl):\\n        if ch_dt[i][j] == 0:\\n            ch_dt[i][j] = 1\\n            path.append((i, j))\\n            if go_path(in_dt, path):\\n                print (\\\"Yes\\\")\\n                return\\nprint(\\\"No\\\")\\n\", \"n, m = map(int, input().split())\\ntabl = []\\nfor l in range(n):\\n    tabl.append(list(input()))\\ndef lstsos(i, j):\\n    nonlocal n, m\\n    ne = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\\n    for l, k in ne:\\n        if 0 <= l < n and 0 <= k < m:\\n            yield (l, k)\\ndef degree(i, j):\\n    deg = 0\\n    for l, k in lstsos(i, j):\\n        deg += (tabl[l][k] == tabl[i][j])\\n    return deg\\nfinished = False\\nwhile not finished:\\n    finished = True\\n    for l in range(n):\\n        for k in range(m):\\n            if tabl[l][k] != 'NO' and degree(l, k) in (0, 1):\\n                tabl[l][k] = 'NO'\\n                finished = False\\ncycle = False\\nfor l in range(n):\\n    for k in range(m):\\n        if tabl[l][k] != 'NO':\\n            cycle = True\\nif cycle:\\n    print (\\\"Yes\\\")\\nelse:\\n    print (\\\"No\\\")\", \"n, m = [int(x) for x in input().split()]\\n\\nfield = [\\\"\\\"] * n\\nlabels = [[0]] * n\\n\\nimport sys\\nsys.setrecursionlimit(10000)\\n\\nfor i in range(n):\\n    field[i] = input().strip()\\n    labels[i] = [0] * m\\n\\ndef is_valid(i, j):\\n    return 0 <= i < n and 0 <= j < m\\n\\n\\ndef dfs(i, j, p, k, cc = 0):\\n    if labels[i][j] == k:\\n        return True\\n    labels[i][j] = k\\n\\n    res = False\\n    dd = [[0, 1], [1, 0], [-1, 0], [0, -1]]\\n    for d in dd:\\n        if is_valid(i + d[0], j + d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):\\n            if field[i + d[0]][j + d[1]] == field[i][j]:\\n                res = res or dfs(i + d[0], j + d[1], [i, j], k, cc + 1)\\n\\n    return res\\n\\nok = False\\nk = 1\\nfor i in range(n):\\n    for j in range(m):\\n        if labels[i][j] == 0:\\n            ok = ok or dfs(i, j, [i, j], k)\\n            k += 1\\n\\nif ok:\\n    print(\\\"Yes\\\")\\nelse:\\n    print(\\\"No\\\")\", \"def main():\\n    n, m = list(map(int, input().split()))\\n    l = [c for _ in range(n) for c in input()]\\n    neigh = []\\n    for y in range(n):\\n        for x in range(m):\\n            yx = y * m + x\\n            neigh.append([])\\n            if x and l[yx] == l[yx - 1]:\\n                neigh[-1].append(yx - 1)\\n                neigh[-2].append(yx)\\n            if y and l[yx] == l[yx - m]:\\n                neigh[-1].append(yx - m)\\n                neigh[-1 - m].append(yx)\\n    field = [0] * len(l)\\n\\n    def dfs(t):\\n        field[t] = 1\\n        for v in neigh[t]:\\n            if not field[v]:\\n                neigh[v].remove(t)\\n                dfs(v)\\n            elif field[v] == 1:\\n                raise OverflowError\\n        field[t] = 2\\n\\n    for i, flag in enumerate(field):\\n        if not flag:\\n            try:\\n                dfs(i)\\n            except OverflowError:\\n                print('Yes')\\n                return\\n    print('No')\\n\\n\\ndef __starting_point():\\n    import sys\\n\\n    sys.setrecursionlimit(10000)\\n    main()\\n\\n__starting_point()\", \"#f = lambda: input()\\n#file = open(\\\"btest\\\", \\\"r\\\")\\n#f = lambda:file.readline()\\n\\n# n, m = map(int, f().split())\\n\\n# g = []\\n\\n# for i in range(n):\\n#     g.append(f())\\n\\n# disco = [[False for _ in range(m)] for _ in range(n)]\\n\\n# #print(disco)\\n# #print(parent)\\n          \\n# def found_cycle(w):\\n#     nonlocal disco\\n#     s = []\\n#     s.append(w)\\n#     while s:\\n#         v = s.pop()\\n#         if disco[v[0]][v[1]] == False:\\n#             if v[0] > 0 and g[v[0]-1][v[1]] == g[v[0]][v[1]]:\\n#                 s.append([v[0]-1, v[1]])\\n                \\n#             if v[0] < n-1 and g[v[0]+1][v[1]] == g[v[0]][v[1]]:\\n#                 s.append([v[0]+1, v[1]])\\n                \\n#             if v[1] > 0 and g[v[0]][v[1]-1] == g[v[0]][v[1]]:\\n#                 s.append([v[0], v[1]-1])\\n                \\n#             if v[1] < m-1 and g[v[0]][v[1]+1] == g[v[0]][v[1]]:\\n#                 s.append([v[0], v[1]+1])\\n                \\n#         else:\\n#             disco[v[0]][v[1]] = True\\n#     return False\\n\\n# found = False\\n# for i in range(n):\\n#     if found:\\n#         break\\n#     for j in range(m):\\n#         if disco[i][j] == False:\\n#             found = found_cycle([i,j])\\n#             break\\n\\n# if found:\\n#     print (\\\"Yes\\\")\\n# else:\\n#     print (\\\"No\\\")\\n\\n#Editorial\\nimport sys\\nsys.setrecursionlimit(10000)\\n\\n#file = open(\\\"btest\\\", \\\"r\\\")\\n#f = lambda:file.readline()\\nf = lambda:input()\\n\\nn,m = list(map(int, f().split()))\\n\\nmatrix = []\\n\\ndisco = [[0 for _ in range(m)] for _ in range(n)]\\n\\nfor i in range(n):\\n    matrix.append(f())\\n\\ndef valid_node(i, j):\\n    return 0 <= i < n and 0 <= j < m\\n\\ndef dfs(i, j, p, k, cc = 0):\\n    if disco[i][j] == k:\\n        return True\\n    \\n    disco[i][j] = k\\n\\n    res = False\\n    dd = [[0,1], [1,0], [-1,0], [0,-1]]\\n    for d in dd:\\n        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):\\n            if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:\\n                res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)\\n\\n    return res\\n\\nok = False\\nk = 1\\nfor i in range(n):\\n    for j in range(m):\\n        if disco[i][j] == 0:\\n            ok = ok or dfs(i, j, [i, j], k)\\n            k += 1\\n\\nif ok:\\n    print(\\\"Yes\\\")\\nelse:\\n    print(\\\"No\\\")\\n\", \"import sys\\n#sys.stdin=open('in.txt')\\nsys.setrecursionlimit(3000)\\nisin = lambda x, y : 0<=x<m and 0<=y<n\\n\\ndef dfs(curx, cury, fax=-1, fay=-1):\\n    nonlocal found\\n    vis[curx][cury]=True\\n    dx=[0, 0,1,-1]\\n    dy=[1,-1,0, 0]\\n    for i in range(4):\\n        newx=curx+dx[i]\\n        newy=cury+dy[i]\\n        if isin(newx,newy) and vis[newx][newy] and G[curx][cury]==G[newx][newy] and not (fax==newx and fay == newy):\\n            found=True\\n        if isin(newx,newy) and not vis[newx][newy] and G[curx][cury]==G[newx][newy] :\\n            dfs(newx,newy,curx, cury)\\n\\nm,n = list(map(int, input().split()))\\nvis=[[False]*n for i in range(m)]\\nfound=False\\nG=[input() for i in range(m)]\\nfor i in range(m):\\n    for j in range(n):\\n        found=False\\n        if not vis[i][j]:\\n            dfs(i,j)\\n        if found:\\n            print('Yes')\\n            return\\n\\nprint('No')\\n\", \"import sys\\n#sys.stdin=open('in.txt')\\nsys.setrecursionlimit(10000)\\nisin = lambda x, y: 0<=x<m and 0<=y<n\\n\\ndef dfs(curx, cury, fax=-1, fay=-1):\\n    nonlocal found\\n    vis[curx][cury]=True\\n    dx=[0, 0, 1, -1]\\n    dy=[1, -1, 0, 0]\\n    for i in range(4):\\n        newx=curx+dx[i]\\n        newy=cury+dy[i]\\n        if isin(newx,newy) and vis[newx][newy] and G[curx][cury]==G[newx][newy] and not (fax == newx and fay == newy):\\n            found=True\\n        if isin(newx,newy) and not vis[newx][newy] and G[curx][cury]==G[newx][newy]:\\n            dfs(newx, newy, curx, cury)   \\n\\nm,n = list(map(int, input().split()))\\nvis=[[False]*n for i in range(m)]\\nfound=False\\nG=[input() for i in range(m)]\\nfor i in range(m):\\n    for j in range(n):\\n        found = False\\n        if not vis[i][j]:\\n            dfs(i, j)\\n        if found:\\n            print('Yes')\\n            return\\nprint('No')    \\n\", \"import sys\\n#sys.stdin=open('in.txt')\\nsys.setrecursionlimit(10000)\\nisin = lambda x, y: 0<=x<m and 0<=y<n\\n\\ndef dfs(curx, cury, fax=-1, fay=-1):\\n    nonlocal found\\n    vis[curx][cury]=True\\n    dx=[0, 0, 1, -1]\\n    dy=[1, -1, 0, 0]\\n    for i in range(4):\\n        newx=curx+dx[i]\\n        newy=cury+dy[i]\\n        if isin(newx,newy) and vis[newx][newy] and G[curx][cury]==G[newx][newy] and not (fax == newx and fay == newy):\\n            found=True\\n            return\\n        if isin(newx,newy) and not vis[newx][newy] and G[curx][cury]==G[newx][newy]:\\n            dfs(newx, newy, curx, cury)   \\n\\nm,n = list(map(int, input().split()))\\nvis=[[False]*n for i in range(m)]\\nfound=False\\nG=[input() for i in range(m)]\\nfor i in range(m):\\n    for j in range(n):\\n        found = False\\n        if not vis[i][j]:\\n            dfs(i, j)\\n        if found:\\n            print('Yes')\\n            return\\nprint('No')    \\n\", \"import sys\\nsys.setrecursionlimit(3000)\\n\\nn,m = map(int, input().split(' '))\\nL = []\\ndx = [-1, 0, 0, 1]\\ndy = [0, -1, 1, 0]\\nfor i in range(n) :\\n    L.append(input())\\n\\ndef dfs(y, x, p_y, p_x, visited) :\\n    nonlocal dx, dy, n, m, L\\n    visited[y][x] = 1\\n    for i in range(4) :\\n        new_y = y + dy[i]\\n        new_x = x + dx[i]\\n        if new_y < 0 or new_y >= n or new_x < 0 or new_x >= m : continue\\n        if new_y == p_y and new_x == p_x : continue\\n        if L[y][x] == L[new_y][new_x] :\\n            if visited[new_y][new_x] == 1: return True\\n            if dfs(new_y, new_x, y, x, visited) : return True\\n    return False\\n\\ndef solve() :\\n    nonlocal n,m,L\\n    visited = [[0 for j in range(m)] for i in range(n)]\\n    for i in range(n) :\\n        for j in range(m) :\\n            if visited[i][j] == 1:continue\\n            if dfs(i, j, -1, -1, visited) :\\n                return True\\n    return False\\n\\nif solve() : print(\\\"Yes\\\")\\nelse : print(\\\"No\\\")\", \"import sys\\n#sys.stdin = open('in.txt')\\nsys.setrecursionlimit(10000)\\nisin = lambda x, y: 0 <= x < n and 0 <= y < m\\n\\ndef dfs(curx, cury, fax = -1, fay = -1):\\n    nonlocal found\\n    vis[curx][cury] = True\\n    dx = [1, -1, 0, 0]\\n    dy = [0, 0, 1, -1]\\n    for i in range(4):\\n        newx = curx + dx[i]\\n        newy = cury + dy[i]\\n        if isin(newx, newy):\\n            if G[curx][cury] == G[newx][newy] and vis [newx][newy] and not (newx == \\n\\nfax and newy == fay):\\n                found = True\\n                print(\\\"Yes\\\")\\n                return\\n            if G[curx][cury] == G[newx][newy] and not vis[newx][newy]:\\n                dfs(newx, newy, curx, cury)\\n\\nn, m = map(int, input().split())\\nvis = [[False] * m for _ in range(n)]\\nG = [input() for _ in range(n)]\\nfound = False\\nfor i in range(n):\\n    for j in range(m):\\n        if not vis[i][j]:\\n            dfs(i, j)\\n        if found:\\n            print('Yes')\\n            return\\nprint('No')\", \"import sys\\ndef dfs(i,j,vis,out,mapp,s=2):\\n    if vis[i][j] and vis[i][j]!= s-1:\\n        return True\\n    t=[(0,1),(1,0),(-1,0),(0,-1)]\\n    vis[i][j]=s\\n    out[i][j]=True\\n    for k in t:\\n        try:\\n            (u,v)=(k[0]+i,k[1]+j)\\n            if u<0 or v<0:\\n                continue\\n            if vis[u][v]!=s-1 and mapp[u][v]==mapp[i][j] and dfs(u,v,vis,out,mapp,s+1):\\n                return True\\n        except Exception:\\n            pass\\n    vis[i][j]=0\\n    return False\\nsys.setrecursionlimit(2500)\\n(n,m)=input().split()\\n(n,m)=(int(n),int(m))\\nexist=set()\\nmapp=[0 for i in range(n)]\\nfor i in range(n):\\n    mapp[i]=input()\\nfor i in range(n):\\n    for j in range(m):\\n        exist.add(mapp[i][j])\\nkey=0\\nt=[(0,1),(1,0),(-1,0),(0,-1)]\\nout=[[False for i in range(m)] for j in range(n)]\\nfor c in exist:\\n    if key:\\n        break\\n    vis=[[0 for i in range(m)] for j in range(n)]\\n    for i in range(n):\\n        if key:\\n            break\\n        for j in range(m):\\n            if key:\\n                break\\n            if mapp[i][j]==c and not out[i][j] and dfs(i,j,vis,out,mapp):\\n                key=1\\n                break\\nif key:\\n    print('Yes')\\nelse:\\n    print('No')\\n                            \\n                \\n\", \"def q():\\n    n,m=map(int,input().split())\\n    p=[k for _ in range(n) for k in input()]\\n    w=[]\\n    for z in range(n):\\n        for j in range(m):\\n            ds=z*m+j\\n            w.append([])\\n            if j and p[ds]==p[ds-1]:\\n                w[-1].append(ds-1)\\n                w[-2].append(ds)\\n            if z and p[ds]==p[ds-m]:\\n                w[-1].append(ds-m)\\n                w[-1-m].append(ds)\\n    pol=[0]*len(p)\\n    def zss(g):\\n            pol[g]=1\\n            for f in w[g]:\\n                if not pol[f]:\\n                    w[f].remove(g)\\n                    zss(f)\\n                elif pol[f]==1:\\n                    raise OverflowError\\n            pol[g]=2\\n    for i,flag in enumerate(pol):\\n        if not flag:\\n            try:\\n                zss(i)\\n            except OverflowError:\\n                print('Yes')\\n                return\\n    print('No')\\nif 1==1:\\n    import sys\\n    sys.setrecursionlimit(10000)\\n    q()\", \"t, u = list(map(int, input().split(' ')))\\n\\ndef ok(x, y, inx):\\n    if not (0 <= x <= t-1 and 0 <= y <= u-1):\\n        return False\\n    if not inx[x][y]:\\n        return False\\n    return True\\n        \\n\\n\\ndef dfs(graph, start, path=[]):\\n    inx = [[False] * u for _ in range(t)]\\n    for i in graph:\\n        a, b = i[0], i[1]\\n        inx[a][b] = True\\n    visited = [[False] * u for _ in range(t)]\\n    parent = [[0] * u for _ in range(t)]\\n    \\n    q=[start]\\n    \\n    while q:\\n        \\n        bd = q.pop(0)\\n        a = bd[0]\\n        b = bd[1]\\n\\n        if not visited[a][b]:\\n            for bad in [(a-1, b), (a, b-1), (a+1, b), (a, b+1)]:\\n                x = bad[0]\\n                y = bad[1]\\n                if ok(x, y, inx):\\n                    if visited[x][y] and (x, y) != parent[a][b]:\\n                        return True\\n                    q=[(x, y)]+q\\n                    parent[x][y] = (a, b)\\n            visited[a][b] = True\\n    return False\\n\\ngraph = {}\\nfor i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\\n    graph[i] = []\\n\\nfor i in range(t):\\n    x = input()\\n    for j in range(u):\\n        graph[x[j]].append((i, j))\\n\\ngraph2 = {}\\nfor i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\\n    if graph[i] != []:\\n        graph2[i] = graph[i]\\n\\nfor i in graph2:\\n    for e in graph2[i]:\\n        if dfs(graph2[i], e):\\n            print(\\\"Yes\\\")\\n            quit()\\n\\n\\nprint(\\\"No\\\")\\n\", \"import sys\\nsys.setrecursionlimit(10000)\\n\\ndef f(i, j):\\n    return -1 < i < n and -1 < j < m\\n\\n\\ndef dfs(c, r, l):\\n    used[c][r] = 1\\n    for (i, j) in {(0, 1), (-1, 0), (1, 0), (0, -1)}:\\n        if f(c + i, r + j) and a[c + i][r + j] == a[c][r]:\\n            if used[c + i][r + j] == 0:\\n                prev[c + i][r + j] = (c, r)\\n                dfs(c + i, r + j, l + 1)\\n            elif used[c + i][r + j] == 1 and prev[c][r] != (c + i, r + j):\\n                nonlocal s \\n                s = \\\"Yes\\\"\\n    used[i][j] = 2\\n            \\n\\n\\nn, m = map(int, input().split())\\na = []\\ns = \\\"No\\\"\\nfor i in range(n):\\n    a.append(list(input().rstrip()))\\n\\nused = [[0 for i in range(m)] for i in range(n)]\\nprev = [[-1 for i in range(m)] for i in range(n)]\\nfor i in range(n):\\n    for j in range(m):\\n        if used[i][j] == 0:\\n            dfs(i, j, 0)\\nprint(s)\", \"import sys\\nsys.setrecursionlimit(10000)\\n\\nn,m = map(int, input().split())\\n\\nboard = []\\nfor _ in range(n):\\n    board.append(input().rstrip())\\n\\nvisited = [[False for _ in range(m)] for _ in range(n)]\\nfoundCycle = False\\n    \\ndx = [1,-1,0,0]\\ndy = [0,0,1,-1]\\n\\ndef dfs(x, y, fromX, fromY, color):\\n    nonlocal board, visited, foundCycle\\n\\n    if x < 0 or x >= n or y < 0 or y >= m: \\n        return\\n    if board[x][y] != color: \\n        return\\n\\n    if visited[x][y]:\\n        foundCycle = True\\n        return\\n    \\n    visited[x][y] = True\\n    for f in range(4):\\n        nextX = x + dx[f]\\n        nextY = y + dy[f]\\n        if nextX == fromX and nextY == fromY:\\n            continue\\n        dfs(nextX, nextY, x, y, color)\\n        \\nfor i in range(n):\\n    for j in range(m):\\n        if not visited[i][j]:\\n            dfs(i,j,-1,-1, board[i][j])\\nprint(\\\"Yes\\\" if foundCycle else \\\"No\\\")\", \"msg_in = input().split()\\nx = int(msg_in[0])\\ny = int(msg_in[1])\\nnum_of_transform = [0, 0]\\nmatrix = []\\nblank = []\\nfor i in range(y+2):\\n    blank.append(' ')\\nmatrix.append(blank)\\nfor i in range(x):\\n    msg_in = input()\\n    matrix.append([' '])    \\n    for j in msg_in:\\n        matrix[i+1].append(j)\\n    matrix[i+1].append(' ')\\nmatrix.append(blank)\\nwhile True:\\n    for i in range(1, x + 1):\\n        for j in range(1, y + 1):\\n            sum = 0\\n            if matrix[i][j] != ' ':\\n                if matrix[i][j-1] == matrix[i][j]:\\n                    sum += 1\\n                if matrix[i][j+1] == matrix[i][j]:\\n                    sum += 1\\n                if matrix[i-1][j] == matrix[i][j]:\\n                    sum += 1\\n                if matrix[i+1][j] == matrix[i][j]:\\n                    sum += 1\\n                if sum < 2:\\n                    matrix[i][j] = ' '\\n                    num_of_transform[0] += 1\\n    if num_of_transform[0] == x * y:\\n        print('No')\\n        break\\n    elif num_of_transform[0] == num_of_transform[1]:\\n        print('Yes')\\n        break\\n    else:\\n        num_of_transform[1] = num_of_transform[0]\\n\", \"# 510B\\nimport string\\n\\n__author__ = 'artyom'\\n\\nn, m = map(int, input().split())\\ngraph = []\\nfor _ in range(n):\\n  graph.append(input())\\n\\n\\ndef neighbours(vertex, colour):\\n  x, y = vertex\\n  res = []\\n  if x > 0 and graph[x - 1][y] == colour:\\n    res.append((x - 1, y))\\n  if y > 0 and graph[x][y - 1] == colour:\\n    res.append((x, y - 1))\\n  if x < n - 1 and graph[x + 1][y] == colour:\\n    res.append((x + 1, y))\\n  if y < m - 1 and graph[x][y + 1] == colour:\\n    res.append((x, y + 1))\\n  return res\\n\\n\\ndef find_cycle(colour, start):\\n  visited = set()\\n  stack = [(start, None)]\\n  while stack:\\n    v, parent = stack.pop()\\n    if v in visited:\\n      return set()\\n    visited.add(v)\\n    for u in neighbours(v, colour):\\n      if u != parent:\\n        stack.append((u, v))\\n  return visited\\n\\n\\nfor c in string.ascii_uppercase:\\n  visited = set()\\n  for i in range(n):\\n    for j in range(m):\\n      if (i, j) not in visited and graph[i][j] == c:\\n        t = find_cycle(c, (i, j))\\n        if not t:\\n          print('Yes')\\n          return\\n        visited |= t\\n\\nprint('No')\", \"# 510B\\n__author__ = 'artyom'\\n\\nn, m = map(int, input().split())\\ngraph = []\\nfor _ in range(n):\\n  graph.append(input())\\n\\n\\ndef neighbours(vertex, colour):\\n  x, y = vertex\\n  res = []\\n  if x > 0 and graph[x - 1][y] == colour:\\n    res.append((x - 1, y))\\n  if y > 0 and graph[x][y - 1] == colour:\\n    res.append((x, y - 1))\\n  if x < n - 1 and graph[x + 1][y] == colour:\\n    res.append((x + 1, y))\\n  if y < m - 1 and graph[x][y + 1] == colour:\\n    res.append((x, y + 1))\\n  return res\\n\\n\\ndef find_cycle(x, y):\\n  colour = graph[x][y]\\n  visited = set()\\n  stack = [((x, y), None)]\\n  while stack:\\n    v, parent = stack.pop()\\n    if v in visited:\\n      return set()\\n    visited.add(v)\\n    for u in neighbours(v, colour):\\n      if u != parent:\\n        stack.append((u, v))\\n  return visited\\n\\n\\nvisited = set()\\nfor i in range(n):\\n  for j in range(m):\\n    if (i, j) not in visited:\\n      t = find_cycle(i, j)\\n      if not t:\\n        print('Yes')\\n        return\\n      visited |= t\\n\\nprint('No')\", \"# coding=utf-8\\nimport sys\\n\\nsys.setrecursionlimit(10000)\\ng = []\\n\\nn, m = list(map(int, input().split()))\\nidx = [[False for i in range(m)] for j in range(n)]\\nfor k in range(n):\\n    g.append(input())\\n\\n\\ndef dfs(i, j, li, lj):\\n    idx[i][j] = True\\n    if i + 1 < n and g[i][j] == g[i + 1][j]:\\n        if idx[i + 1][j] is False:\\n            return dfs(i + 1, j, i, j)\\n        elif not (li == i and lj == j) and i + 1 != li:\\n            return 'Yes'\\n    if i - 1 >= 0 and g[i][j] == g[i - 1][j]:\\n        if idx[i - 1][j] is False:\\n            return dfs(i - 1, j, i, j)\\n        elif not (li == i and lj == j) and i - 1 != li:\\n            return 'Yes'\\n    if j - 1 >= 0 and g[i][j] == g[i][j - 1]:\\n        if idx[i][j - 1] is False:\\n            return dfs(i, j - 1, i, j)\\n        elif not (li == i and lj == j) and j - 1 != lj:\\n            return 'Yes'\\n    if j + 1 < m and g[i][j] == g[i][j + 1]:\\n        if idx[i][j + 1] is False:\\n            return dfs(i, j + 1, i, j)\\n        elif not (li == i and lj == j) and j + 1 != lj:\\n            return 'Yes'\\n    return None\\n\\n\\nfor i in range(n):\\n    for j in range(m):\\n        if not idx[i][j]:\\n            ans = dfs(i, j, i, j)\\n            if ans:\\n                print(ans)\\n                break\\n    else:\\n        continue\\n    break\\nelse:\\n    print('No')\\n\", \"#A\\n'''\\nn, m = map(int, input().split())\\nrow = ['#' * m if i % 2 == 0 else '.' * (m - 1) + '#' if i % 4 == 1\\n       else '#' + '.' * (m - 1) for i in range(n)]\\nprint('\\\\n'.join(row))\\n'''\\n#B\\nimport sys\\nsys.setrecursionlimit(5000)\\nn, m = list(map(int, input().split()))\\ndx = [-1, 0, 0, 1]\\ndy = [0, -1, 1, 0]\\nL = list(input() for i in range(n))\\n\\ndef check(x, y, px, py):\\n    return (x >= 0 and x < n and y >= 0 and y < m)\\n            \\n\\ndef DFS(x, y, px, py, visited):\\n    #print(x, y, px, py, '\\\\n', visited)\\n    visited[x][y] = True\\n    for i in range(4):\\n        newx = x + dx[i]\\n        newy = y + dy[i]\\n        if not check(newx, newy, px, py): continue\\n        if (newx == px and newy == py): continue\\n        #print('Bug ', visited)\\n        if L[x][y] == L[newx][newy]:\\n            if visited[newx][newy]:\\n                #print('Here True', newx, newy, x, y)\\n                return True\\n            if DFS(newx, newy, x, y, visited):\\n                #print(newx, newy, x, y, visited)\\n                return True\\n    return False\\n        \\ndef solve():\\n#    visited = [[False] * m] * n\\n    visited = [[False for j in range(m)] for i in range(n)]    \\n    for i in range(n):\\n        for j in range(m):\\n            if visited[i][j]: continue\\n            if DFS(i, j, -1, -1, visited): return True\\n    return False\\n\\nprint('Yes' if solve() else 'No')\\n'''\\n3 3\\nAAA\\nABA\\nABA\\n'''\\n\"]",
        "difficulty": "interview",
        "input": "3 4\nAAAA\nABCA\nAAAA\n",
        "output": "Yes\n",
        "halu_type": "Data Compliance Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/510/B"
    }
]