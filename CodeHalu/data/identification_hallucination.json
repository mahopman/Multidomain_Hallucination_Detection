[
    {
        "id": 279,
        "task_id": 2273,
        "test_case_id": 3,
        "question": "You have a simple undirected graph consisting of $n$ vertices and $m$ edges. The graph doesn't contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected.\n\nLet's make a definition.\n\nLet $v_1$ and $v_2$ be two some nonempty subsets of vertices that do not intersect. Let $f(v_{1}, v_{2})$ be true if and only if all the conditions are satisfied:  There are no edges with both endpoints in vertex set $v_1$.  There are no edges with both endpoints in vertex set $v_2$.  For every two vertices $x$ and $y$ such that $x$ is in $v_1$ and $y$ is in $v_2$, there is an edge between $x$ and $y$. \n\nCreate three vertex sets ($v_{1}$, $v_{2}$, $v_{3}$) which satisfy the conditions below;  All vertex sets should not be empty.  Each vertex should be assigned to only one vertex set.  $f(v_{1}, v_{2})$, $f(v_{2}, v_{3})$, $f(v_{3}, v_{1})$ are all true. \n\nIs it possible to create such three vertex sets? If it's possible, print matching vertex set for each vertex.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($3 \\le n \\le 10^{5}$, $0 \\le m \\le \\text{min}(3 \\cdot 10^{5}, \\frac{n(n-1)}{2})$)\u00a0\u2014 the number of vertices and edges in the graph.\n\nThe $i$-th of the next $m$ lines contains two integers $a_{i}$ and $b_{i}$ ($1 \\le a_{i} \\lt b_{i} \\le n$)\u00a0\u2014 it means there is an edge between $a_{i}$ and $b_{i}$. The graph doesn't contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected.\n\n\n-----Output-----\n\nIf the answer exists, print $n$ integers. $i$-th integer means the vertex set number (from $1$ to $3$) of $i$-th vertex. Otherwise, print $-1$.\n\nIf there are multiple answers, print any.\n\n\n-----Examples-----\nInput\n6 11\n1 2\n1 3\n1 4\n1 5\n1 6\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6\n\nOutput\n1 2 2 3 3 3 \nInput\n4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example, if $v_{1} = \\{ 1 \\}$, $v_{2} = \\{ 2, 3 \\}$, and $v_{3} = \\{ 4, 5, 6 \\}$ then vertex sets will satisfy all conditions. But you can assign vertices to vertex sets in a different way; Other answers like \"2 3 3 1 1 1\" will be accepted as well. [Image] \n\nIn the second example, it's impossible to make such vertex sets.",
        "solutions": "[\"import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\n\\nN, M = list(map(int, input().split()))\\nE = [[] for _ in range(N)]\\nfor _ in range(M):\\n    a, b = list(map(int, input().split()))\\n    E[a-1].append(b-1)\\n    E[b-1].append(a-1)\\n\\ninf = 1 << 20\\nA, B, C = [], [], []\\nX = [0] * N\\nfor a in E[0]:\\n    X[a] = 1\\nA = [i for i in range(N) if X[i]==0]\\nb = min([i for i in range(N) if X[i] == 1] + [inf])\\nif b < inf:\\n    for a in E[b]:\\n        if X[a] == 1: X[a] = 2\\n    B = [i for i in range(N) if X[i]==1]\\nc = min([i for i in range(N) if X[i] == 2] + [inf])\\nif c < inf:\\n    for a in E[c]:\\n        if X[a] == 2: X[a] = 3\\n    C = [i for i in range(N) if X[i]==2]\\n\\nif max(X) == 2 and len(A) * len(B) * len(C) and (len(A) + len(B) + len(C) == N) and (len(A) * len(B) + len(B) * len(C) + len(A) * len(C) == M):\\n    f = 0\\n    for i in range(N):\\n        for j in E[i]:\\n            if X[i] == X[j]:\\n                f = 1\\n                break\\n        if f: break\\n    if f:\\n        print(-1)\\n    else:\\n        print(*[x+1 for x in X])\\nelse:\\n    print(-1)\\n\", \"n,m = list(map(int, input().split()))\\n\\nad = [[] for _ in range(n)]\\n\\nes = []\\nfor _ in range(m):\\n    v,u = list(map(int, input().split()))\\n    v-=1\\n    u-=1\\n    es.append((min(v,u),max(v,u)))\\nes = sorted(es, key=lambda x: (x[0], x[1]))\\n\\nfor e in es:\\n    v, u = e\\n    ad[v].append(str(u))\\n    ad[u].append(str(v))\\n\\n\\nad = [''.join(a) for a in ad]\\nd = {}\\nfor t in ad:\\n    if t not in d:\\n        d[t] = str(len(d) + 1)\\n    if len(d) > 3:\\n        print(-1)\\n        return\\nif len(d) != 3:\\n    print(-1)\\n    return\\n\\nans = []\\nfor t in ad:\\n    ans.append(d[t])\\nprint(' '.join(ans))\\n\", \"from collections import defaultdict, deque\\n\\n\\ndef threeSets(vs, es, d):\\n    sets = [3] * vs\\n    \\n    s1 = 0\\n    dist = [float('inf')] * vs\\n    sets[s1] = 1\\n    dist[s1] = 0\\n    queue = deque([s1])\\n    while queue:\\n        v1 = queue.pop()\\n        for v2 in d[v1]:\\n            if dist[v2] > dist[v1] + 1:\\n                dist[v2] = dist[v1] + 1\\n                queue.appendleft(v2)\\n    \\n    for i in range(vs):\\n        if dist[i] > 2:\\n            return [-1]\\n        elif dist[i] == 2:\\n            sets[i] = 1\\n        \\n    try:\\n        s2 = sets.index(3)\\n    except:\\n        return [-1]\\n    \\n    dist = [float('inf')] * vs\\n    sets[s2] = 2\\n    dist[s2] = 0\\n    queue = deque([s2])\\n    while queue:\\n        v1 = queue.pop()\\n        for v2 in d[v1]:\\n            if dist[v2] > dist[v1] + 1:\\n                dist[v2] = dist[v1] + 1\\n                queue.appendleft(v2)\\n    \\n    for i in range(vs):\\n        if dist[i] > 2:\\n            return [-1]\\n        elif dist[i] == 2:\\n            if sets[i] == 1:\\n                return [-1]\\n            else:\\n                sets[i] = 2\\n                \\n    VS = [set() for i in range(3)]\\n    for i in range(vs):\\n        g = sets[i] - 1\\n        VS[g].add(i)\\n    for V in VS:\\n        if not len(V):\\n            return [-1]\\n        \\n    for v1 in VS[0]:\\n        for v2 in VS[1]:\\n            if v2 not in d[v1]:\\n                return [-1]\\n        \\n        for v2 in VS[2]:\\n            if v2 not in d[v1]:\\n                return [-1]\\n    \\n    for v1 in VS[1]:\\n        for v2 in VS[2]:\\n            if v2 not in d[v1]:\\n                return [-1]\\n            \\n    valid_es = len(VS[0]) * len(VS[1]) + len(VS[0]) * len(VS[2]) + len(VS[1]) * len(VS[2])\\n    return sets if es == valid_es else [-1]       \\n        \\n    \\nd = defaultdict(set)\\n\\nvs, es = list(map(int, input().split()))\\nfor _ in range(es):\\n    v1, v2 = list(map(int, input().split()))\\n    v1 -= 1\\n    v2 -= 1\\n    d[v1].add(v2)\\n    d[v2].add(v1)\\n        \\nprint(*threeSets(vs, es, d))\\n\", \"# python template for atcoder1\\nimport sys\\nsys.setrecursionlimit(10**9)\\ninput = sys.stdin.readline\\n\\n\\nclass UnionFind:\\n    def __init__(self, N):\\n        self.parent = [i for i in range(N)]\\n        self.size = [1 for _ in range(N)]\\n\\n    def find(self, x):\\n        if self.parent[x] == x:\\n            return x\\n        else:\\n            return self.find(self.parent[x])\\n\\n    def union(self, x, y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px == py:\\n            return\\n        if self.size[px] < self.size[py]:\\n            self.parent[px] = py\\n            self.size[py] += self.size[px]\\n        else:\\n            self.parent[py] = px\\n            self.size[px] += self.size[py]\\n\\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\n    def connectedNum(self, x):\\n        return self.size[self.find(x)]\\n\\n    def component_NUM(self):\\n        par = set()\\n        for i in self.parent:\\n            par.add(self.find(i))\\n        return len(par)\\n\\n\\nN, M = list(map(int, input().split()))\\nadj = [set() for _ in range(N)]\\nUn = UnionFind(N)\\nfor _ in range(M):\\n    a, b = [int(x)-1 for x in input().split()]\\n    adj[a].add(b)\\n    adj[b].add(a)\\n\\nadded = set()\\nrepresentative = set()\\nfor i in range(N):\\n    if i in added:\\n        continue\\n    added.add(i)\\n    representative.add(i)\\n    for j in range(i+1, N):\\n        if j in added:\\n            continue\\n        if adj[i] == adj[j]:\\n            added.add(j)\\n            Un.union(i, j)\\n    if len(representative) > 3:\\n        print(-1)\\n        return\\nif Un.component_NUM() == 3:\\n    group = {}\\n    ans = []\\n    for p in range(N):\\n        par = Un.find(p)\\n        if par not in list(group.keys()):\\n            group[par] = len(group)+1\\n        ans.append(group[par])\\n    print(\\\" \\\".join(map(str, ans)))\\nelse:\\n    print(-1)\\n\", \"def main():\\n    from array import array\\n    from sys import stdin, stdout\\n    n, m = list(map(int, stdin.readline().split()))\\n    inp = {tuple(map(int, stdin.readline().split())) for _ in range(m)}\\n    ans = array('b', (0,)) * (n + 1)\\n    ans[1] = 1\\n    c1 = 1\\n    c2 = c3 = 0\\n    i = 1\\n    for j in range(2, n + 1):\\n        if (1, j) not in inp:\\n            ans[j] = 1\\n            c1 += 1\\n        else:\\n            if i == 1:\\n                i = j\\n            if (i, j) in inp:\\n                ans[j] = 2\\n                c2 += 1\\n            else:\\n                ans[j] = 3\\n                c3 += 1\\n    if m != c1 * (c2 + c3) + c2 * c3 or not c2:\\n        stdout.write('-1')\\n    else:\\n        for i, j in inp:\\n            if ans[i] == ans[j]:\\n                stdout.write('-1')\\n                break\\n        else:\\n            stdout.write(' '.join((str(ansi) for ansi in ans if ansi)))\\n\\n\\nmain()\\n\", \"\\\"\\\"\\\"\\nNTC here\\n\\\"\\\"\\\"\\nfrom sys import setcheckinterval, stdin, setrecursionlimit\\nsetcheckinterval(1000)\\nsetrecursionlimit(10**7)\\n \\n# print(\\\"Case #{}: {} {}\\\".format(i, n + m, n * m))\\n \\n \\ndef iin(): return int(stdin.readline())\\n \\n \\ndef lin(): return list(map(int, stdin.readline().split()))\\n\\ndef BFS(s, adj):\\n    parent = {s: None}\\n    color = [-1]*(len(adj))\\n    color[s]+=1\\n    u = [s]\\n    while u:  # runs till u is []\\n        nextu = []\\n        for i in u:\\n            for v in adj[i]:\\n                if v not in parent:\\n                    color[v]=(color[i]+1)%3\\n                    parent[v] = i\\n                    nextu.append(v)\\n                else:\\n                    if color[v]==color[i]:\\n                        color[v]=(color[v]+1)%3\\n        u = nextu.copy()\\n    for i in range(len(adj)):\\n        color[i]+=1\\n    return color\\n\\n\\n\\nn,m=lin()\\nadj=[[] for i in range(n)]\\nfor _ in range(m):\\n    i,j=lin()\\n    adj[i-1].append(j-1)\\n    adj[j-1].append(i-1)\\n\\nsol=BFS(0, adj)\\nc1=[0,0,0] #count of 1,2,3\\nfor i in sol:\\n    if i==0:\\n        print(-1)\\n        return\\n    c1[i-1]+=1\\nch=[[0 for i in range(3)] for j in range(3)] #12,13,23\\n\\nfor v in range(n):\\n    for u in adj[v]:\\n        ch[sol[v]-1][sol[u]-1]+=1\\n#        ch[sol[u]-1][sol[v]-1]+=1\\n        if sol[v]==sol[u]:\\n            print(-1)\\n            return\\na12=ch[0][1]+ch[1][0]\\na13=ch[0][2]+ch[2][0]\\na23=ch[1][2]+ch[2][1]\\n#print(a12,a13,a23,c1,sol)\\nif a12==2*c1[0]*c1[1] and a13==2*c1[0]*c1[2] and a23==2*c1[1]*c1[2]:\\n    print(*sol)\\nelse:\\n    print(-1)\", \"n, m = map(int, input().split())\\nG = [[] for _ in range(n)]\\nfor i in range(m):\\n\\ta, b = map(int, input().split())\\n\\ta -= 1\\n\\tb -= 1\\n\\tG[a].append(b)\\n\\tG[b].append(a)\\n\\nif len(G[0]) < 2:\\n\\tprint(-1)\\n\\treturn\\n\\nres = [1]*n\\nfor a in G[0]:\\n\\tres[a] = 2\\na2 = G[0][0]\\nfor b in G[a2]:\\n\\tif res[b] == 2: res[b] = 3\\nsizes = [n-len(G[0]), n-len(G[a2]), len(G[0])+len(G[a2])-n]\\nif 0 in sizes:\\n\\tprint(-1)\\n\\treturn\\n\\nfor i in range(n):\\n\\tg = res[i]\\n\\ts = sizes[g-1]\\n\\tif len(G[i]) != n-s:\\n\\t\\tprint(-1)\\n\\t\\treturn\\n\\tfor j in G[i]:\\n\\t\\tif res[j] == g:\\n\\t\\t\\tprint(-1)\\n\\t\\t\\treturn\\n\\nprint(*res)\", \"import sys\\ninput = sys.stdin.readline\\nfrom collections import deque\\nn, m = [int(item) for item in input().split()]\\nab = []\\nedges = [[] for _ in range(n)]\\n\\nfor i in range(m):\\n    a, b = [int(item) for item in input().split()]\\n    a -= 1; b -= 1\\n    edges[a].append(b)\\n    edges[b].append(a)\\n    ab.append((a, b))\\n\\n    \\ngroupA = [1] * n\\nfor a, b in ab:\\n    if a == 0:\\n        groupA[b] = 0\\n    elif b == 0:\\n        groupA[a] = 0\\npar = None\\nfor i, item in enumerate(groupA):\\n    if item == 0:\\n        par = i\\n        break\\nif par == None:\\n    print(-1)\\n    return\\n\\ngroupB = [1] * n\\nfor a, b in ab:\\n    if a == par:\\n        groupB[b] = 0\\n    elif b == par:\\n        groupB[a] = 0\\n\\npar = None\\nfor i, (p, q) in enumerate(zip(groupA, groupB)):\\n    if p == 0 and q == 0:\\n        par = i\\n        break\\nif par == None:\\n    print(-1)\\n    return\\n\\ngroupC = [1] * n\\nfor a, b in ab:\\n    if a == par:\\n        groupC[b] = 0\\n    elif b == par:\\n        groupC[a] = 0\\n\\n# Check edge num\\nsumA = sum(groupA)\\nsumB = sum(groupB)\\nsumC = sum(groupC)\\ne_abc = [0, n - sumA, n - sumB, n - sumC]\\nedge_num = sumA * sumB + sumB * sumC + sumC * sumA \\nif edge_num != m:\\n    print(-1)\\n    return\\n\\n# Answer\\nsetA = set()\\nsetB = set()\\nsetC = set()\\ngroup = [groupA, groupB, groupC]\\nret = []\\nfor i, (ga, gb, gc) in enumerate(zip(groupA, groupB, groupC)):\\n    total = ga + gb + gc\\n    if total != 1:\\n        print(-1)\\n        return\\n    if ga:\\n        ret.append(1)\\n        setA.add(i)\\n    elif gb:\\n        ret.append(2)\\n        setB.add(i)\\n    else:\\n        ret.append(3)\\n        setC.add(i)\\ns_ABC = [set(), setA, setB, setC]\\nfor i, item in enumerate(ret):\\n    if e_abc[item] != len(edges[i]):\\n        print(-1)\\n        return\\n    for node in edges[i]:\\n        if node in s_ABC[item]:\\n            print(-1)\\n            return\\nprint(\\\" \\\".join([str(item) for item in ret]))\", \"import sys\\ninput = sys.stdin.readline\\n\\nn,m=list(map(int,input().split()))\\nE=[set() for i in range(n+1)]\\nECOUNT=[0]*(n+1)\\n\\nfor i in range(m):\\n    x,y=list(map(int,input().split()))\\n    E[x].add(y)\\n    E[y].add(x)\\n    ECOUNT[x]+=1\\n    ECOUNT[y]+=1\\n\\n\\nGroup=[i for i in range(n+1)]\\n\\ndef find(x):\\n    while Group[x] != x:\\n        x=Group[x]\\n    return x\\n\\ndef Union(x,y):\\n    if find(x) != find(y):\\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\\n\\nSCORE=0\\nfor i in range(1,n+1):\\n    if find(i)==i:\\n        SCORE+=1\\n        if SCORE>=6:\\n            print(-1)\\n            return\\n            \\n        for j in range(i+1,n+1):\\n            if j in E[i]:\\n                continue\\n            else:\\n                Union(i,j)\\n\\nFD=[find(i) for i in range(n+1)]\\nif len(set(FD[1:]))!=3:\\n    print(-1)\\n    return\\n\\nfor i in range(n+1):\\n    for j in E[i]:\\n        if FD[i]==FD[j]:\\n            print(-1)\\n            return\\n\\n\\ncompression_dict={a: ind for ind, a in enumerate(sorted(set(FD)))}\\nANS=[compression_dict[a] for a in FD]\\n\\nVFD=[0,0,0]\\nEFD=[0,0,0]\\nfor i in range(1,n+1):\\n    VFD[ANS[i]-1]+=1\\n    EFD[ANS[i]-1]+=ECOUNT[i]\\n\\nfor i in range(3):\\n    VS=0\\n    for j in range(3):\\n        if i==j:\\n            continue\\n        VS+=VFD[i]*VFD[j]\\n\\n    if EFD[i]==VS:\\n        continue\\n    else:\\n        print(-1)\\n        return\\n\\n\\nprint(*ANS[1:])\\n\\n\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn,m=list(map(int,input().split()))\\nE=[set() for i in range(n+1)]\\nECOUNT=[0]*(n+1)\\n\\nfor i in range(m):\\n    x,y=list(map(int,input().split()))\\n    E[x].add(y)\\n    E[y].add(x)\\n    ECOUNT[x]+=1\\n    ECOUNT[y]+=1\\n\\n\\nGroup=[i for i in range(n+1)]\\n\\ndef find(x):\\n    while Group[x] != x:\\n        x=Group[x]\\n    return x\\n\\ndef Union(x,y):\\n    if find(x) != find(y):\\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\\n\\nSCORE=0\\nfor i in range(1,n+1):\\n    if find(i)==i:\\n        SCORE+=1\\n        if SCORE>=4:\\n            print(-1)\\n            return\\n            \\n        for j in range(i+1,n+1):\\n            if j in E[i]:\\n                continue\\n            else:\\n                Union(i,j)\\n\\nFD=[find(i) for i in range(n+1)]\\nif len(set(FD[1:]))!=3:\\n    print(-1)\\n    return\\n\\nfor i in range(n+1):\\n    for j in E[i]:\\n        if FD[i]==FD[j]:\\n            print(-1)\\n            return\\n\\n\\ncompression_dict={a: ind for ind, a in enumerate(sorted(set(FD)))}\\nANS=[compression_dict[a] for a in FD]\\n\\nVFD=[0,0,0]\\nEFD=[0,0,0]\\nfor i in range(1,n+1):\\n    VFD[ANS[i]-1]+=1\\n    EFD[ANS[i]-1]+=ECOUNT[i]\\n\\nfor i in range(3):\\n    VS=0\\n    for j in range(3):\\n        if i==j:\\n            continue\\n        VS+=VFD[i]*VFD[j]\\n\\n    if EFD[i]==VS:\\n        continue\\n    else:\\n        print(-1)\\n        return\\n\\n\\nprint(*ANS[1:])\\n\\n\\n\", \"from sys import stdin\\ninput = stdin.readline\\nv, e = map(int,input().split())\\nd = {}\\nfor i in range(1, v+1):\\n\\td[i] = []\\nfor ed in range(e):\\n\\ta,b = map(int,input().split())\\n\\td[a].append(b)\\n\\td[b].append(a)\\nfor i in d:\\n\\td[i].sort()\\nsas = {}\\nfor i in d:\\n\\tsas[tuple(d[i])] = 0\\nif len(sas) != 3:\\n\\tprint(-1)\\nelse:\\n\\tnbs = []\\n\\tfor i in sas:\\n\\t\\tnbs.append(set(i))\\n\\ta = nbs[0].intersection(nbs[1])\\n\\tb = nbs[0].intersection(nbs[2])\\n\\tc = nbs[1].intersection(nbs[2])\\n\\tkol = [0]*(v+1)\\n\\tfor i in a:\\n\\t\\tkol[i] = 1\\n\\tfor i in b:\\n\\t\\tkol[i] = 2\\n\\tfor i in c:\\n\\t\\tkol[i] = 3\\n\\tzer = 0\\n\\tfor i in range(1,len(kol)):\\n\\t\\tif kol[i] == 0:\\n\\t\\t\\tzer += 1\\n\\t\\t\\tbreak\\n\\tif zer > 0:\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\tif len(a)+len(b)+len(c) !=v:\\n\\t\\t\\tprint(-1)\\n\\t\\telse:\\n\\t\\t\\tprint(*kol[1:])\", \"# https://codeforces.com/contest/1228/problem/D\\n# all neightbor in group --> pass 1\\n# all neighbor not in group --> merge 0\\n# invalid 2\\n# WA\\ndef type_(list_v, group):\\n    cnt_0 = 0\\n    cnt_1 = 0\\n    \\n    for v in list_v:\\n        if v in group:\\n            cnt_1 += 1\\n        else:\\n            cnt_0 += 1\\n            \\n    if cnt_1 == len(group):\\n        return 1\\n    \\n    if cnt_0 == len(list_v):\\n        return 0\\n    \\n    return 2\\n    \\ndef is_all_type_1(ex_index, list_group, v):\\n    for i, group in list(list_group.items()):\\n        if i == ex_index:\\n            continue\\n            \\n        if type_(g[v], group) != 1: \\n            return False\\n        \\n    return True\\n    \\ndef check(v, list_group):\\n    t = None\\n    for i, group in list(list_group.items()):\\n        t  = type_(g[v], group)\\n        \\n        if t == 0 or t == 2:\\n            if t == 0:\\n                if is_all_type_1(i, list_group, v) == True:\\n                    group[v] = 1\\n                else:\\n                    return 2\\n            return t\\n        \\n    return t    \\n    \\ngroup = {}    \\ndef process(g):    \\n    for v in g:\\n        if len(group) == 0:\\n            group[0]    = {}\\n            group[0][v] = 1\\n            continue\\n    \\n        t = check(v, group)\\n        \\n        if t == 2:\\n            return -1\\n        \\n        if t == 1:\\n            if len(group) == 3:\\n                return -1\\n            \\n            group[len(group)]    = {}\\n            group[len(group)-1][v] = 1\\n    return group\\n\\ng = {}\\nn, m = list(map(int, input().split()))\\n\\nfor _ in range(m):\\n    u, v = list(map(int, input().split()))\\n    if u not in g:\\n        g[u] = []\\n    if v not in g:\\n        g[v] = []\\n        \\n    g[u].append(v)    \\n    g[v].append(u)\\n    \\nans = process(g)\\n\\nif ans == -1 or len(ans) < 3:\\n    print(-1)\\nelse:\\n    pr  = [0] * n\\n    \\n    cnt = 0\\n    for k, gr in list(group.items()):\\n        for v in gr:\\n            cnt += 1\\n            pr[v-1] = str(k+1)\\n    \\n    if cnt == n:\\n        print(' '.join(pr))\\n    else:\\n        print(-1)\\n# 1,2  3,4  5,6\\n#6 12\\n#1 3\\n#1 4\\n#2 3\\n#2 4\\n#1 5 \\n#1 6\\n#2 5\\n#2 6\\n#3 5\\n#3 6\\n#4 5\\n#4 6\\n\", \"from collections import defaultdict,deque\\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\\nsys.setrecursionlimit(10**8)\\nINF = float('inf')\\nmod = 10**9+7\\neps = 10**-7\\ndef inp(): return int(sys.stdin.readline())\\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\\ndef inpl_str(): return list(sys.stdin.readline().split())\\n\\nN,M = inpl()\\n\\nif M == 0:\\n    print(-1)\\n    return\\n\\ncnts = [0]*N\\nlines = defaultdict(set)\\nfor _ in range(M):\\n    a,b = inpl()\\n    a-=1 ; b-=1\\n    cnts[a] += 1\\n    cnts[b] += 1\\n    lines[a].add(b)\\n    lines[b].add(a)\\n\\nsetc = set(cnts)\\nL = len(setc)\\nans = [-1]*N\\nif L == 1:\\n    ans[a] = 1\\n    ans[b] = 2\\n    for i in range(N):\\n        if ans[i] != 0:\\n            if i not in lines[a]:\\n                ans[i] = 1\\n            elif i not in lines[b]:\\n                ans[i] = 2\\n            else:\\n                ans[i] = 3\\nelif L == 2:\\n    c1,c2 = list(setc)\\n    if c1*2 + c2 == N*2:\\n        i1 = cnts.index(c1)\\n        i2 = cnts.index(c2)\\n        for i,c in enumerate(cnts):\\n            if c == c2:\\n                ans[i] = 2\\n            else:\\n                if i not in lines[i1]:\\n                    ans[i] = 1\\n                else:\\n                    ans[i] = 3\\n    elif c1 + c2*2 == N*2:\\n        i1 = cnts.index(c1)\\n        i2 = cnts.index(c2)\\n        for i,c in enumerate(cnts):\\n            if c == c1:\\n                ans[i] = 1\\n            else:\\n                if i not in lines[i2]:\\n                    ans[i] = 2\\n                else:\\n                    ans[i] = 3\\n    else:\\n        print(-1)\\n        return\\nelif L == 3:\\n    c1,c2,c3 = list(setc)\\n    for i,c in enumerate(cnts):\\n        if c == c1:\\n            ans[i] = 1\\n        elif c == c2:\\n            ans[i] = 2\\n        elif c == c3:\\n            ans[i] = 3\\nelse:\\n    print(-1)\\n    return\\n\\n\\nif len(set(ans)) != 3:\\n    print(-1)\\n    return\\n\\nfor s in range(N):\\n    for t in lines[s]:\\n        if ans[s] == ans[t]:\\n            print(-1)\\n            return\\n\\nprint(' '.join(map(str,ans)))\\n\", \"import sys\\ndef fill(graph,n):\\n    \\n    dp=[[True,True,True] for _ in range(n+1)]\\n    l=[-1 for i in range(n+1)]\\n    from collections import defaultdict\\n    vis=defaultdict(int)\\n    count1,count2,count3=0,0,0\\n    for i in graph:\\n        if dp[i][0]:\\n            #fill\\n            l[i],count1=1,count1+1\\n            vis[i]=1\\n            for j in graph[i]:\\n                dp[j][0]=False\\n        elif dp[i][1]:\\n            #fill\\n            l[i]=2\\n            count2+=1\\n            vis[i]=2\\n            for j in graph[i]:\\n                dp[j][1]=False\\n        elif dp[i][2]:\\n            #fill\\n            l[i]=3\\n            count3+=1\\n            vis[i]=3\\n            for j in graph[i]:\\n                dp[j][2]=False\\n        else:\\n            return [-1]\\n    \\n    if count1==0 or count2==0 or count3==0:\\n        return [-1]\\n    if count1+count2+count3!=n:\\n        return [-1]\\n    if count1*count2+count2*count3+count1*count3!=m:\\n        return [-1]\\n    l.pop(0)\\n    for i in l:\\n        if i==-1:\\n            return [-1]\\n    return l\\nn,m=list(map(int,sys.stdin.readline().split()))\\nfrom collections import defaultdict\\ngraph=defaultdict(list)\\nfor i in range(m):\\n    a,b=list(map(int,sys.stdin.readline().split()))\\n    graph[a].append(b)\\n    graph[b].append(a)\\nk=fill(graph,n)\\nprint(*k)\\n\", \"a=list(map(int,input().split()))\\nn=a[0]\\ne=a[1]\\ng={}\\nfor itr in range(1,n+1):\\n    g[itr]=[]\\nfor i in range(e):\\n    a=list(map(int,input().split()))\\n    g[a[0]].append(a[1])\\n    g[a[1]].append(a[0])\\nfor itr in range(1,n+1):\\n    g[itr]=frozenset(g[itr])\\na={}\\nk=1\\nres=[]\\nfor i in range(1,n+1):\\n    if len(g[i])==0:\\n        k=100\\n        break\\n    if g[i] in a: \\n        res.append(a[g[i]])\\n    else: \\n        a[g[i]]=k\\n        k+=1\\n        res.append(a[g[i]])\\n    if len(a)>3:break\\nif k!=4 : print(-1)\\nelse: print(*res)\", \"n,m=list(map(int,input().split()))\\nEE=[]\\nif m<3:\\n  print(-1)\\nelse:\\n  edge = [set() for i in range(n)]\\n  a,b=list(map(int,input().split()))\\n  edge[a-1].add(b-1)\\n  edge[b-1].add(a-1)\\n  EE.append([a-1,b-1])\\n\\n  for i in range(m-1):\\n    x,y=list(map(int,input().split()))\\n    edge[x-1].add(y-1)\\n    edge[y-1].add(x-1)\\n    EE.append([x-1,y-1])\\n  c=0  \\n  for i in range(n):\\n    if a-1 in edge[i] and b-1 in edge[i]:\\n      c=i+1\\n      break\\n  if c==0:\\n    print(-1)\\n  else:\\n    Ans=[0]*n\\n    Ans[a-1]=1\\n    Ans[b-1]=2\\n    Ans[c-1]=3\\n    flg=True\\n    C=[1]*3\\n    for i in range(n):\\n      if Ans[i]!=0:\\n        continue\\n      else:\\n        E=edge[i]\\n        if a-1 in E and b-1 in E and c-1 not in E:\\n          Ans[i]=3\\n          C[2]+=1\\n        elif a-1 in E and b-1 not in E and c-1 in E:\\n          Ans[i]=2\\n          C[1]+=1\\n        elif a-1 not in E and b-1 in E and c-1 in E:\\n          Ans[i]=1\\n          C[0]+=1\\n        else:\\n          print(-1)\\n          flg=False\\n          break\\n    if flg:\\n      T=[0]*3\\n      for x,y in EE:\\n        xx,yy=Ans[x],Ans[y]\\n        if xx==yy:\\n          print(-1)\\n          flg=False\\n          break\\n        elif xx==1 and yy==2:\\n          T[0]+=1\\n        elif xx==2 and yy==1:\\n          T[0]+=1\\n        elif xx==1 and yy==3:\\n          T[1]+=1\\n        elif xx==3 and yy==1:\\n          T[1]+=1\\n        else:\\n          T[2]+=1\\n    if flg:\\n      if T[0]==C[0]*C[1] and T[1]==C[0]*C[2] and T[2]==C[1]*C[2]:\\n        print(*Ans)\\n      else:\\n        print(-1)\\n\\n\\n\\n\\n\\n\", \"import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\n \\nN, M = map(int, input().split())\\nE = [[] for _ in range(N)]\\nfor _ in range(M):\\n    a, b = map(int, input().split())\\n    E[a-1].append(b-1)\\n    E[b-1].append(a-1)\\n \\ninf = 1 << 20\\nA, B, C = [], [], []\\nX = [0] * N\\nfor a in E[0]:\\n    X[a] = 1\\nA = [i for i in range(N) if X[i]==0]\\nb = min([i for i in range(N) if X[i] == 1] + [inf])\\nif b < inf:\\n    for a in E[b]:\\n        if X[a] == 1: X[a] = 2\\n    B = [i for i in range(N) if X[i]==1]\\nc = min([i for i in range(N) if X[i] == 2] + [inf])\\nif c < inf:\\n    for a in E[c]:\\n        if X[a] == 2: X[a] = 3\\n    C = [i for i in range(N) if X[i]==2]\\n \\nif max(X) == 2 and len(A) * len(B) * len(C) and (len(A) + len(B) + len(C) == N) and (len(A) * len(B) + len(B) * len(C) + len(A) * len(C) == M):\\n    f = 0\\n    for i in range(N):\\n        for j in E[i]:\\n            if X[i] == X[j]:\\n                f = 1\\n                break\\n        if f: break\\n    if f:\\n        print(-1)\\n    else:\\n        print(*[x+1 for x in X])\\nelse:\\n    print(-1)\", \"n,m=list(map(int,input().split()))\\nEE=[]\\nif m<3:\\n  print(-1)\\nelse:\\n  edge = [[] for i in range(n)]\\n  a,b=list(map(int,input().split()))\\n  edge[a-1].append(b-1)\\n  edge[b-1].append(a-1)\\n  EE.append([a-1,b-1])\\n\\n  for i in range(m-1):\\n    x,y=list(map(int,input().split()))\\n    edge[x-1].append(y-1)\\n    edge[y-1].append(x-1)\\n    EE.append([x-1,y-1])\\n  c=0  \\n  for i in range(n):\\n    if a-1 in edge[i] and b-1 in edge[i]:\\n      c=i+1\\n      break\\n  if c==0:\\n    print(-1)\\n  else:\\n    Ans=[0]*n\\n    Ans[a-1]=1\\n    Ans[b-1]=2\\n    Ans[c-1]=3\\n    flg=True\\n    C=[1]*3\\n    for i in range(n):\\n      if Ans[i]!=0:\\n        continue\\n      else:\\n        E=edge[i]\\n        if a-1 in E and b-1 in E and c-1 not in E:\\n          Ans[i]=3\\n          C[2]+=1\\n        elif a-1 in E and b-1 not in E and c-1 in E:\\n          Ans[i]=2\\n          C[1]+=1\\n        elif a-1 not in E and b-1 in E and c-1 in E:\\n          Ans[i]=1\\n          C[0]+=1\\n        else:\\n          print(-1)\\n          flg=False\\n          break\\n    if flg:\\n      T=[0]*3\\n      for x,y in EE:\\n        xx,yy=Ans[x],Ans[y]\\n        if xx==yy:\\n          print(-1)\\n          flg=False\\n          break\\n        elif xx==1 and yy==2:\\n          T[0]+=1\\n        elif xx==2 and yy==1:\\n          T[0]+=1\\n        elif xx==1 and yy==3:\\n          T[1]+=1\\n        elif xx==3 and yy==1:\\n          T[1]+=1\\n        else:\\n          T[2]+=1\\n    if flg:\\n      if T[0]==C[0]*C[1] and T[1]==C[0]*C[2] and T[2]==C[1]*C[2]:\\n        print(*Ans)\\n      else:\\n        print(-1)\\n\\n\\n\\n\\n\\n\", \"3\\n\\nimport array\\nimport math\\nimport os\\nimport random\\nimport sys\\n\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n    return sys.stdin.readline().rstrip()\\n\\n\\ndef dprint(*value, sep=' ', end='\\\\n'):\\n    if DEBUG:\\n        print(*value, sep=sep, end=end)\\n\\n\\ndef solve(N, M, G):\\n    A = {}\\n\\n    for i in range(N):\\n        t = frozenset(G[i])\\n        if t not in A:\\n            A[t] = set([i])\\n        else:\\n            A[t].add(i)\\n\\n    if len(A) != 3:\\n        return None\\n\\n    (a1, v1), (a2, v2), (a3, v3) = A.items()\\n    v1 = frozenset(v1)\\n    v2 = frozenset(v2)\\n    v3 = frozenset(v3)\\n\\n    if a1 != v2 | v3 or a2 != v3 | v1 or a3 != v1 | v2:\\n        return None\\n\\n    ans = [0] * N\\n    for v in v1:\\n        ans[v] = 1\\n    for v in v2:\\n        ans[v] = 2\\n    for v in v3:\\n        ans[v] = 3\\n    return ans\\n\\n\\ndef main():\\n    N, M = [int(e) for e in inp().split()]\\n    G = [[] for _ in range(N)]\\n    for _ in range(M):\\n        a, b = [int(e) - 1 for e in inp().split()]\\n        G[a].append(b)\\n        G[b].append(a)\\n\\n    ans = solve(N, M, G)\\n    if not ans:\\n        print('-1')\\n    else:\\n        print(*ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"3\\n\\nimport math\\nimport os\\nimport sys\\n\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n    return sys.stdin.readline().rstrip()\\n\\n\\ndef dprint(*value, sep=' ', end='\\\\n'):\\n    if DEBUG:\\n        print(*value, sep=sep, end=end)\\n\\n\\ndef solve(N, M, G):\\n    A = {}\\n\\n    for i in range(N):\\n        t = frozenset(G[i])\\n        if t not in A:\\n            A[t] = set([i])\\n        else:\\n            A[t].add(i)\\n\\n    if len(A) != 3:\\n        return None\\n\\n    (a1, v1), (a2, v2), (a3, v3) = A.items()\\n    v1 = frozenset(v1)\\n    v2 = frozenset(v2)\\n    v3 = frozenset(v3)\\n\\n    if a1 != v2 | v3 or a2 != v3 | v1 or a3 != v1 | v2:\\n        return None\\n\\n    ans = [0] * N\\n    for v in v1:\\n        ans[v] = 1\\n    for v in v2:\\n        ans[v] = 2\\n    for v in v3:\\n        ans[v] = 3\\n    return ans\\n\\n\\ndef main():\\n    N, M = [int(e) for e in inp().split()]\\n    G = [[] for _ in range(N)]\\n    for _ in range(M):\\n        a, b = [int(e) - 1 for e in inp().split()]\\n        G[a].append(b)\\n        G[b].append(a)\\n\\n    ans = solve(N, M, G)\\n    if not ans:\\n        print('-1')\\n    else:\\n        print(*ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n,m=map(int,input().split())\\nmaxi=1000009\\nd={}\\na=[['0'] for i in range(n+1)]\\n\\nfor i in range(m):\\n    u,v=map(int,input().split())\\n    a[u].append(str(v)+'*')\\n    a[v].append(str(u)+'*')\\n\\ncount=1\\nfor i in range(1,n+1):\\n    if len(a[i])==1:\\n        print(\\\"-1\\\")\\n        return\\n    a[i].sort()\\nfor i in range(1,n+1):    \\n    a[i]=\\\"\\\".join(a[i])\\n    #print(a[i])\\nfor i in range(1,n+1):\\n    if a[i] not in d:\\n        d[a[i]]=count\\n        count+=1\\n#print(d)  \\nif len(d)!=3:\\n    #print(s)\\n    print(\\\"-1\\\")\\n    return\\nfor i in range(1,n+1):\\n    print(d[a[i]],end=\\\" \\\")\\n  \", \"n,m=map(int,input().split())\\nd={}\\na=[['0'] for i in range(n+1)]\\nfor i in range(m):\\n    u,v=map(int,input().split())\\n    a[u].append(str(v)+'*')\\n    a[v].append(str(u)+'*')\\ncount=1\\nfor i in range(1,n+1):\\n    if len(a[i])==1:\\n        print(\\\"-1\\\")\\n        return\\n    a[i].sort()\\nfor i in range(1,n+1):    \\n    a[i]=\\\"\\\".join(a[i])\\nfor i in range(1,n+1):\\n    if a[i] not in d:\\n        d[a[i]]=count\\n        count+=1\\nif len(d)!=3:\\n    print(\\\"-1\\\")\\n    return\\nfor i in range(1,n+1):\\n    print(d[a[i]],end=\\\" \\\")\\n  \\n    \", \"n,m=map(int,input().split())\\nd={}\\na=[['0'] for i in range(n+1)]\\nfor i in range(m):\\n    u,v=map(int,input().split())\\n    a[u].append(str(v)+'*')\\n    a[v].append(str(u)+'*')\\ncount=1\\nfor i in range(1,n+1):\\n    if len(a[i])==1:\\n        print(\\\"-1\\\")\\n        return\\n    a[i].sort()\\nfor i in range(1,n+1):    \\n    a[i]=\\\"\\\".join(a[i])\\nfor i in range(1,n+1):\\n    if a[i] not in d:\\n        d[a[i]]=count\\n        count+=1\\nif len(d)!=3:\\n    print(\\\"-1\\\")\\n    return\\nfor i in range(1,n+1):\\n    print(d[a[i]],end=\\\" \\\")\\n  \", \"try:\\n    from string_source import string_source\\nexcept ImportError:\\n    source = input\\n\\nfrom collections import defaultdict\\n\\n\\ndef complete_bipartite(n, edges):\\n    if not edges:\\n        return False\\n\\n    neighbors = defaultdict(set, {})\\n\\n    for e1, e2 in edges:\\n        neighbors[e1].add(e2)\\n        neighbors[e2].add(e1)\\n\\n    s1, s2 = edges[0]\\n\\n    groups = [None, None, None]\\n    groups[2] = neighbors[s1].intersection(neighbors[s2])\\n    groups[1] = neighbors[s1].difference(neighbors[s2])\\n    groups[0] = set(neighbors).difference(groups[2], groups[1])\\n\\n    def get_group(node):\\n        return next(idx for idx, g in enumerate(groups) if node in g)\\n\\n    sizes = [len(g) for g in groups]\\n\\n    if sum(len(g) for g in groups) < n:\\n        return False\\n    if any(len(g) == 0 for g in groups):\\n        return False\\n\\n    for e1, e2 in edges:\\n        if get_group(e1) == get_group(e2):\\n            return False\\n\\n    answer = [0] * n\\n    for node, neigh in list(neighbors.items()):\\n        g = get_group(node)\\n        if sum(s for idx, s in enumerate(sizes) if idx != g) != len(neigh):\\n            return False\\n\\n        answer[node - 1] = g + 1\\n\\n    return answer\\n\\n\\ndef answer(source):\\n    n, m = list(map(int, source().strip().split()))\\n    edges = [[int(k) for k in source().strip().split()] for _ in range(m)]\\n\\n    a = complete_bipartite(n, edges)\\n    if not a:\\n        print(-1)\\n    else:\\n        print(\\\" \\\".join(map(str, a)))\\n\\n\\nanswer(input)\\n\\nif False:\\n    answer(\\n        string_source(\\n            \\\"\\\"\\\"6 11\\n    1 2\\n    1 3\\n    1 4\\n    1 5\\n    1 6\\n    2 4\\n    2 5\\n    2 6\\n    3 4\\n    3 5\\n    3 6\\\"\\\"\\\"\\n        )\\n    )\\n\\n    answer(\\n        string_source(\\n            \\\"\\\"\\\"4 6\\n    1 2\\n    1 3\\n    1 4\\n    2 3\\n    2 4\\n    3 4\\\"\\\"\\\"\\n        )\\n    )\\n\"]",
        "difficulty": "interview",
        "input": "3 0\n",
        "output": "-1\n",
        "halu_type": "Identification Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/1228/D"
    }
]